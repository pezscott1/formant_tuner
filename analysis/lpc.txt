"""
LPC-based formant estimation for vocal analysis.

This module is tuned for:
- 1-channel, 24-bit, 48 kHz vocal recordings
- real-time analysis
- calibration + tuning workflows

Key features:
- Adaptive LPC order (safe for 48 kHz bright mics)
- Mic-aware pre-emphasis (stronger at high sample rates)
- Pole filtering by frequency and bandwidth
- Harmonic / ridge mitigation via spectral-envelope fallback
- Confidence scoring
- Rich debug payload for diagnostics and plotting
"""

from __future__ import annotations
import logging
from dataclasses import dataclass, asdict
from typing import List, Optional, Tuple, Dict, Any, cast
import numpy as np
from numpy.typing import NDArray
from scipy.signal import find_peaks

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Data structures
# ---------------------------------------------------------------------------

@dataclass
class FormantResult:
    """Container for a single-frame formant analysis result."""

    f1: Optional[float]
    f2: Optional[float]
    f3: Optional[float]
    confidence: float
    method: str              # "lpc", "fallback", or "none"
    peaks: List[float]       # spectral envelope peak freqs
    roots: List[float]       # LPC root frequencies (Hz)
    bandwidths: List[float]  # LPC root bandwidths (Hz)
    lpc_order: int
    debug: Dict[str, Any]    # optional extra diagnostic fields

    def to_dict(self) -> Dict[str, Any]:
        """Convenience method to convert to a plain dict for JSON/engine."""
        return asdict(self)


@dataclass
class LPCConfig:
    """Configuration for LPC analysis."""
    # Core
    win_len_ms: float = 30.0
    # For 48 kHz bright vocal mics, 10–14 is a good sweet spot
    min_order: int = 10
    max_order: int = 14
    # Pre-emphasis (set to 0 to disable, or None for auto)
    pre_emph: Optional[float] = None
    # Frequency constraints
    f_low: float = 80.0
    f_high: float = 4000.0
    max_bandwidth: float = 600.0
    # Spectral fallback
    lifter_cut: int = 60
    nfft: int = 8192
    peak_thresh: float = 0.02
    # Confidence scaling
    base_confidence: float = 0.7
    # Mic profile: "bright_48k" reserved for future compensation logic
    mic_profile: str = "bright_48k"


# ---------------------------------------------------------------------------
# Core public API
# ---------------------------------------------------------------------------

def estimate_formants(
    y: NDArray[np.float64] | NDArray[np.float32],
    sr: int,
    config: Optional[LPCConfig] = None,
    debug: bool = False,
) -> FormantResult:
    """
    High-level entry point for formant estimation.

    Returns:
        FormantResult with f1/f2/f3, confidence, method, peaks, roots, bandwidths.
    """
    if config is None:
        config = LPCConfig()

    # Basic validation
    if y is None or sr is None or sr <= 0:
        return _empty_result("none", lpc_order=0, reason="invalid_input")

    y = np.asarray(y, dtype=float).flatten()
    if y.size == 0:
        return _empty_result("none", lpc_order=0, reason="empty_frame")

    # Pre-emphasis (auto if None)
    pre_emph = config.pre_emph
    if pre_emph is None:
        # For 48 kHz bright mics, stronger pre-emphasis makes sense
        pre_emph = 0.97 if sr >= 44100 else 0.95

    if pre_emph > 0:
        y = np.append(y[0], y[1:] - pre_emph * y[:-1])

    # Windowing
    win_len = int(sr * config.win_len_ms / 1000.0)
    win_len = min(win_len, len(y))
    if win_len < 256:
        return _empty_result("none", lpc_order=0, reason="window_too_short")

    frame = y[:win_len] * np.hamming(win_len)

    # Adaptive LPC order
    order = _choose_lpc_order(sr, win_len, config)
    if len(frame) < 3 * order:
        return _empty_result("none", lpc_order=order, reason="insufficient_samples_for_order")

    # LPC coefficients via Levinson–Durbin
    A = _compute_lpc(frame, order)
    if A is None:
        return _fallback_formants(frame, sr, config, order, reason="levinson_failed")

    # Bandwidth expansion
    bw_factor = 0.994
    A = A * (bw_factor ** np.arange(len(A)))

    # Roots
    try:
        roots = np.roots(A)
    except Exception:
        logger.exception("LPC root finding failed")
        return _fallback_formants(frame, sr, config, order, reason="root_fail")

    if roots.size == 0:
        return _fallback_formants(frame, sr, config, order, reason="no_roots")

    # Frequencies & bandwidths
    ang = np.angle(roots)
    freqs = ang * (sr / (2 * np.pi))
    bw_vals = -0.5 * (sr / np.pi) * np.log(np.abs(roots))

    # Filter poles
    mask = (
        (freqs > config.f_low)
        & (freqs < config.f_high)
        & (bw_vals > 0)
        & (bw_vals < config.max_bandwidth)
    )
    freqs_f = freqs[mask].real
    bw_f = bw_vals[mask].real

    if freqs_f.size == 0:
        return _fallback_formants(frame, sr, config, order, reason="no_valid_poles")

    freqs_sorted = np.sort(freqs_f)
    bw_sorted = np.array([bw for _, bw in sorted(zip(freqs_f, bw_f), key=lambda t: t[0])])

    # Derive F1/F2/F3 with a sanity check against mic-induced ridge behavior
    f1, f2, f3 = _extract_formants_from_poles(freqs_sorted, config)

    # If first pole > 1000 Hz, likely mic tilt / mis-tracking → fallback
    if f1 is not None and f1 > 1000:
        return _fallback_formants(frame, sr, config, order, reason="f1_too_high_lpc")

    if f1 is None and f2 is None:
        return _fallback_formants(frame, sr, config, order, reason="no_formants_from_poles")

    # Spectral envelope peaks (for confidence + plotting)
    peak_freqs, peak_heights = smoothed_spectrum_peaks(
        frame,
        sr,
        lifter_cut=config.lifter_cut,
        nfft=config.nfft,
        low=int(config.f_low),
        high=int(config.f_high),
        peak_thresh=config.peak_thresh,
    )

    confidence = _estimate_confidence(
        f1,
        f2,
        f3,
        freqs_sorted,
        peak_freqs,
        peak_heights,
        config,
        method="lpc",
    )

    debug_payload: Dict[str, Any] = {}
    if debug:
        debug_payload = {
            "freqs_poles": freqs_sorted.tolist(),
            "bw_poles": bw_sorted.tolist(),
            "peak_freqs": peak_freqs.tolist(),
            "peak_heights": peak_heights.tolist(),
            "pre_emph": pre_emph,
        }

    return FormantResult(
        f1=f1,
        f2=f2,
        f3=f3,
        confidence=confidence,
        method="lpc",
        peaks=peak_freqs.tolist(),
        roots=freqs_sorted.tolist(),
        bandwidths=bw_sorted.tolist(),
        lpc_order=order,
        debug=debug_payload,
    )


def estimate_formants_lpc_legacy(
    y,
    sr,
    order=None,
    win_len_ms=30,
    pre_emph=0.0,
    debug: bool = False,
):
    """
    Legacy-compatible wrapper.

    Returns:
        (f1, f2, f3)   when debug=False
        (f1, f2, f3, debug_data) when debug=True

    This keeps older code paths working while using the new engine internally.
    """
    cfg = LPCConfig(
        win_len_ms=win_len_ms,
        pre_emph=pre_emph if pre_emph > 0 else None,
    )
    if order is not None:
        cfg.min_order = order
        cfg.max_order = order

    result = estimate_formants(y, sr, config=cfg, debug=debug)

    if debug:
        return result.f1, result.f2, result.f3, result.debug
    return result.f1, result.f2, result.f3


# ---------------------------------------------------------------------------
# LPC core helpers
# ---------------------------------------------------------------------------

def _choose_lpc_order(sr: int, win_len: int, cfg: LPCConfig) -> int:
    """
    Choose an LPC order that is safe for bright 48 kHz vocal mics.
    """
    # Base heuristic: ~sr/4000, clamped
    base = int(sr / 4000)
    order = max(cfg.min_order, min(cfg.max_order, base))

    # If frame is very short, further clamp
    if win_len < 1024:
        order = max(cfg.min_order, min(order, 10))

    return order


def _compute_lpc(frame: NDArray[np.float64], order: int) -> Optional[np.ndarray]:
    """Autocorrelation + Levinson–Durbin to get LPC coefficients."""
    try:
        R_full = np.correlate(frame, frame, mode="full")
        mid = len(R_full) // 2
        r = R_full[mid: mid + order + 1]
        A = _levinson_durbin(r, order)
        return A
    except Exception:
        logger.exception("LPC computation failed")
        return None


def _levinson_durbin(r: np.ndarray, order: int) -> Optional[np.ndarray]:
    """
    Levinson–Durbin recursion for LPC coefficients from autocorrelation.
    Returns LPC coeffs a[0..order] or None on failure.
    """
    if r.size < order + 1 or r[0] <= 0:
        return None

    a = np.zeros(order + 1, dtype=float)
    e = float(r[0])
    a[0] = 1.0

    for i in range(1, order + 1):
        acc = 0.0
        for j in range(1, i):
            acc += a[j] * r[i - j]
        k = -(r[i] + acc) / e

        a_prev = a.copy()
        a[1:i] = a_prev[1:i] + k * a_prev[i - 1:0:-1]
        a[i] = k
        e *= (1.0 - k * k)
        if e <= 0:
            return None

    return a


def _extract_formants_from_poles(freqs_sorted: np.ndarray, _cfg: LPCConfig) -> (
        Tuple)[Optional[float], Optional[float], Optional[float]]:
    """
    Simple F1/F2/F3 extraction from sorted pole frequencies, with
    basic physiological guardrails.
    """
    if freqs_sorted.size == 0:
        return None, None, None

    plausible = freqs_sorted.copy()

    # Basic sanity: enforce monotonicity, drop duplicated / ultra-close poles
    unique: List[float] = []
    last = None
    for f in plausible:
        if last is None or abs(f - last) > 50:  # 50 Hz separation
            unique.append(float(f))
            last = f

    if not unique:
        return None, None, None

    f1 = unique[0] if len(unique) > 0 else None
    f2 = unique[1] if len(unique) > 1 else None
    f3 = unique[2] if len(unique) > 2 else None

    # Drop clearly impossible combos for vocals:
    # f1 should be below ~1000, f2 should be > f1
    if f1 is not None and f1 < 80:
        f1 = cast(Optional[float], None)
    if f2 is not None and f1 is not None and f2 <= f1:
        f2 = cast(Optional[float], None)
    if f3 is not None and f2 is not None and f3 <= f2:
        f3 = cast(Optional[float], None)

    return f1, f2, f3


# ---------------------------------------------------------------------------
# Spectral envelope + peaks
# ---------------------------------------------------------------------------

def smoothed_spectrum_peaks(
    frame: NDArray[np.float64],
    sr: int,
    lifter_cut: int = 60,
    nfft: int = 8192,
    low: int = 50,
    high: int = 4000,
    peak_thresh: float = 0.02,
) -> Tuple[NDArray[np.float64], NDArray[np.float64]]:
    """
    Cepstral lifter smoothing to extract spectral-envelope peaks.
    Returns (peak_freqs_array, heights_array).
    """
    try:
        win = frame * np.hamming(len(frame))
        X = np.abs(np.fft.rfft(win, n=nfft))
        logX = np.log(X + 1e-12)
        cep = np.fft.irfft(logX)
        lifter_cut = max(1, lifter_cut)
        cep[lifter_cut:-lifter_cut] = 0
        smooth_log = np.fft.rfft(cep, n=nfft).real
        env = np.exp(smooth_log)
        freqs = np.fft.rfftfreq(nfft, 1.0 / sr)
        mask = (freqs >= low) & (freqs <= high)
        if not np.any(mask):
            return np.array([], dtype=np.float64), np.array([], dtype=np.float64)

        return _extract_peak_data(env, freqs, mask, peak_thresh)

    except Exception as e:
        logger.exception("smoothed_spectrum_peaks failed: %s", e)
        return np.array([], dtype=np.float64), np.array([], dtype=np.float64)


def _extract_peak_data(
    env: np.ndarray,
    freqs: np.ndarray,
    mask: np.ndarray,
    peak_thresh: float,
) -> Tuple[np.ndarray, np.ndarray]:
    """Shared helper to extract peak frequencies and heights."""
    env_masked = env[mask]
    if env_masked.size == 0:
        return np.empty(0, dtype=np.float64), np.empty(0, dtype=np.float64)

    from numpy.typing import NDArray

    peaks: NDArray[np.int_]
    peaks, props = find_peaks(env_masked, height=np.max(env_masked) * peak_thresh)

    if peaks.size == 0:
        return np.empty(0, dtype=np.float64), np.empty(0, dtype=np.float64)

    idx_list: List[int] = [int(p) for p in np.asarray(peaks).ravel()]
    peak_freqs = np.asarray(
        np.round(freqs[mask][idx_list], 1), dtype=np.float64
    )
    heights = np.asarray(
        np.round(env_masked[idx_list], 2), dtype=np.float64
    )
    return peak_freqs, heights


# ---------------------------------------------------------------------------
# Confidence + fallback
# ---------------------------------------------------------------------------

def _fallback_formants(
    frame: NDArray[np.float64],
    sr: int,
    cfg: LPCConfig,
    order: int,
    reason: str,
) -> FormantResult:
    """
    Spectral-envelope-based fallback when LPC fails or is clearly misbehaving.
    """
    peak_freqs, peak_heights = smoothed_spectrum_peaks(
        frame,
        sr,
        lifter_cut=cfg.lifter_cut,
        nfft=cfg.nfft,
        low=int(cfg.f_low),
        high=int(cfg.f_high),
        peak_thresh=cfg.peak_thresh,
    )

    if peak_freqs.size == 0:
        return _empty_result(
            "none",
            lpc_order=order,
            reason=f"fallback_no_peaks:{reason}",
        )

    peaks_sorted = np.sort(peak_freqs)
    f1 = float(peaks_sorted[0]) if peaks_sorted.size > 0 else None
    f2 = float(peaks_sorted[1]) if peaks_sorted.size > 1 else None
    f3 = float(peaks_sorted[2]) if peaks_sorted.size > 2 else None

    confidence = _estimate_confidence(
        f1,
        f2,
        f3,
        freqs_poles=None,
        peak_freqs=peak_freqs,
        peak_heights=peak_heights,
        cfg=cfg,
        method="fallback",
    )

    debug_payload = {
        "reason": reason,
        "peak_freqs": peak_freqs.tolist(),
        "peak_heights": peak_heights.tolist(),
    }

    return FormantResult(
        f1=f1,
        f2=f2,
        f3=f3,
        confidence=confidence,
        method="fallback",
        peaks=peak_freqs.tolist(),
        roots=[],
        bandwidths=[],
        lpc_order=order,
        debug=debug_payload,
    )


def _empty_result(method: str, lpc_order: int, reason: str) -> FormantResult:
    """Create an empty result with zero confidence."""
    return FormantResult(
        f1=None,
        f2=None,
        f3=None,
        confidence=0.0,
        method=method,
        peaks=[],
        roots=[],
        bandwidths=[],
        lpc_order=lpc_order,
        debug={"reason": reason},
    )


def _estimate_confidence(
    f1: Optional[float],
    f2: Optional[float],
    _f3: Optional[float],
    freqs_poles: Optional[np.ndarray],
    peak_freqs: np.ndarray,
    peak_heights: np.ndarray,
    cfg: LPCConfig,
    method: str,
) -> float:
    """
    Heuristic confidence score:
    - presence of formants
    - alignment between LPC poles and spectral peaks
    - method type (LPC vs fallback)
    """
    _ = peak_heights
    if f1 is None and f2 is None:
        return 0.0

    score = cfg.base_confidence

    # More poles → higher potential confidence (LPC only)
    if method == "lpc" and freqs_poles is not None and freqs_poles.size > 0:
        score += min(0.2, 0.01 * freqs_poles.size)

    # Peak alignment
    if peak_freqs.size > 0 and f1 is not None:
        dists = np.abs(peak_freqs - f1)
        score += float(np.exp(-dists.min() / 200.0)) * 0.2 if dists.size > 0 else 0.0

    if peak_freqs.size > 1 and f2 is not None:
        dists = np.abs(peak_freqs - f2)
        score += float(np.exp(-dists.min() / 300.0)) * 0.2 if dists.size > 0 else 0.0

    # Clamp to [0, 1]
    return float(max(0.0, min(1.0, score)))
